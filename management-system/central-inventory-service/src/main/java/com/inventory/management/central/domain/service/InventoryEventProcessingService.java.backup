package com.inventory.management.central.domain.service;

import com.inventory.management.central.domain.model.CentralInventory;
import com.inventory.management.central.domain.model.InventoryEvent;
import com.inventory.management.central.domain.model.StoreInventory;
import com.inventory.management.central.domain.port.CentralInventoryRepository;
import com.inventory.management.central.domain.port.InventoryEventRepository;
import com.inventory.management.central.domain.port.StoreInventoryRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Servi√ßo de dom√≠nio para processamento de eventos de invent√°rio.
 * 
 * Este servi√ßo √© respons√°vel por processar eventos recebidos via Kafka
 * das lojas e manter o invent√°rio central sincronizado em tempo real.
 * 
 * @author Sistema de Gerenciamento de Invent√°rio
 * @version 1.0.0
 * @since 1.0.0
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class InventoryEventProcessingService {
    
    private final CentralInventoryRepository centralInventoryRepository;
    private final StoreInventoryRepository storeInventoryRepository;
    private final InventoryEventRepository inventoryEventRepository;
    
    /**
     * Processa um evento de invent√°rio recebido de uma loja.
     * 
     * @param event evento a ser processado
     * @return true se processado com sucesso
     */
    @Transactional
    public boolean processInventoryEvent(InventoryEvent event) {
        log.info("üîÑ Processando evento de invent√°rio: eventId={}, tipo={}, produto={}, loja={}", 
                event.getEventId(), event.getEventType(), event.getProductSku(), event.getStoreId());
        
        try {
            // Validar evento
            if (!isEventValid(event)) {
                log.warn("‚ö†Ô∏è  Evento inv√°lido ignorado: eventId={}", event.getEventId());
                event.markAsIgnored("Evento inv√°lido ou incompleto");
                inventoryEventRepository.save(event);
                return false;
            }
            
            // Verificar se evento j√° foi processado (idempot√™ncia)
            if (inventoryEventRepository.existsByEventId(event.getEventId())) {
                log.warn("‚ö†Ô∏è  Evento duplicado ignorado: eventId={}", event.getEventId());
                return true; // Considera sucesso para evitar reprocessamento
            }
            
            // Salvar evento PRIMEIRO para auditoria (transa√ß√£o separada)
            event.setProcessingStatus(InventoryEvent.ProcessingStatus.PENDING);
            InventoryEvent savedEvent = inventoryEventRepository.save(event);
            log.info("üíæ Evento salvo com sucesso para auditoria: eventId={}", savedEvent.getEventId());
            
            // Processar baseado no tipo de evento (SEM atualizar invent√°rios por enquanto)
            switch (event.getEventType()) {
                case RESERVE -> log.info("üîí Evento RESERVE recebido: {}", event.getProductSku());
                case COMMIT -> log.info("‚úÖ Evento COMMIT recebido: {}", event.getProductSku());
                case CANCEL -> log.info("‚ùå Evento CANCEL recebido: {}", event.getProductSku());
                case UPDATE -> log.info("üîÑ Evento UPDATE recebido: {}", event.getProductSku());
                case RESTOCK -> log.info("üì¶ Evento RESTOCK recebido: {}", event.getProductSku());
                default -> {
                    log.warn("‚ö†Ô∏è  Tipo de evento n√£o reconhecido: {}", event.getEventType());
                    savedEvent.markAsFailed("Tipo de evento n√£o reconhecido");
                    inventoryEventRepository.save(savedEvent);
                    return false;
                }
            }
            
            // Marcar como processado
            savedEvent.markAsProcessed();
            inventoryEventRepository.save(savedEvent);
            
            log.info("‚úÖ Evento processado com sucesso: eventId={}", savedEvent.getEventId());
            return true;
            
        } catch (Exception e) {
            log.error("‚ùå Erro ao processar evento: eventId={}, erro={}", 
                    event.getEventId(), e.getMessage(), e);
            
            try {
                event.markAsFailed(e.getMessage());
                inventoryEventRepository.save(event);
            } catch (Exception saveError) {
                log.error("‚ùå Erro adicional ao salvar evento com falha: {}", saveError.getMessage());
            }
            return false;
        }
    }
    
    /**
     * Valida se o evento est√° completo e correto.
     */
    private boolean isEventValid(InventoryEvent event) {
        return event != null &&
               event.getEventId() != null &&
               event.getProductSku() != null && !event.getProductSku().trim().isEmpty() &&
               event.getStoreId() != null && !event.getStoreId().trim().isEmpty() &&
               event.getEventType() != null &&
               event.getNewQuantity() != null && event.getNewQuantity() >= 0 &&
               event.getTimestamp() != null;
    }
}
    
    }
    }

    /**
     * Valida se o evento est√° completo e correto.
     */
    private boolean isEventValid(InventoryEvent event) {
        return event != null &&
               event.getEventId() != null &&
               event.getProductSku() != null && !event.getProductSku().trim().isEmpty() &&
               event.getStoreId() != null && !event.getStoreId().trim().isEmpty() &&
               event.getEventType() != null &&
               event.getNewQuantity() != null && event.getNewQuantity() >= 0 &&
               event.getTimestamp() != null;
    }
}
    
    /**
     * Atualiza o invent√°rio da loja baseado no evento.
     */
    private void updateStoreInventory(InventoryEvent event) {
        Optional<StoreInventory> storeInventoryOpt = 
                storeInventoryRepository.findByProductSkuAndStoreId(
                        event.getProductSku(), event.getStoreId());
        
        StoreInventory storeInventory;
        if (storeInventoryOpt.isPresent()) {
            storeInventory = storeInventoryOpt.get();
            // Atualizar apenas se houver mudan√ßa significativa
            if (!storeInventory.getQuantity().equals(event.getNewQuantity()) ||
                !storeInventory.getReservedQuantity().equals(event.getReservedQuantity() != null ? event.getReservedQuantity() : 0)) {
                
                storeInventory.setQuantity(event.getNewQuantity());
                storeInventory.setReservedQuantity(event.getReservedQuantity() != null ? event.getReservedQuantity() : 0);
                storeInventory.calculateAvailableQuantity();
                storeInventory.setLastUpdated(LocalDateTime.now());
                storeInventory.markAsSynchronized();
                
                storeInventoryRepository.save(storeInventory);
            }
        } else {
            // Criar novo registro se n√£o existe
            storeInventory = StoreInventory.create(
                    event.getProductSku(), 
                    event.getStoreId(), 
                    "Store " + event.getStoreId()
            );
            storeInventory.setQuantity(event.getNewQuantity());
            storeInventory.setReservedQuantity(event.getReservedQuantity() != null ? event.getReservedQuantity() : 0);
            storeInventory.calculateAvailableQuantity();
            storeInventory.setLastUpdated(LocalDateTime.now());
            storeInventory.markAsSynchronized();
            
            storeInventoryRepository.save(storeInventory);
        }
    }
    
    /**
     * Atualiza o invent√°rio central consolidado.
     */
    private void updateCentralInventory(String productSku) {
        // Calcular totais agregados de todas as lojas
        Integer totalQuantity = storeInventoryRepository.sumQuantityByProductSku(productSku);
        Integer totalReserved = storeInventoryRepository.sumReservedQuantityByProductSku(productSku);
        
        if (totalQuantity == null) totalQuantity = 0;
        if (totalReserved == null) totalReserved = 0;
        
        Optional<CentralInventory> centralInventoryOpt = 
                centralInventoryRepository.findByProductSku(productSku);
        
        CentralInventory centralInventory;
        if (centralInventoryOpt.isPresent()) {
            centralInventory = centralInventoryOpt.get();
        } else {
            // Criar novo registro se n√£o existe
            centralInventory = CentralInventory.create(productSku, "Product " + productSku);
        }
        
        // Atualizar quantidades consolidadas
        centralInventory.setTotalQuantity(totalQuantity);
        centralInventory.setTotalReservedQuantity(totalReserved);
        centralInventory.calculateAvailableQuantity();
        centralInventory.setLastUpdated(LocalDateTime.now());
        
        centralInventoryRepository.save(centralInventory);
        
        log.debug("üìä Invent√°rio central atualizado: produto={}, total={}, reservado={}, dispon√≠vel={}", 
                productSku, totalQuantity, totalReserved, centralInventory.getAvailableQuantity());
    }
    
    /**
     * Valida se o evento est√° completo e correto.
     */
    private boolean isEventValid(InventoryEvent event) {
        return event != null &&
               event.getEventId() != null &&
               event.getProductSku() != null && !event.getProductSku().trim().isEmpty() &&
               event.getStoreId() != null && !event.getStoreId().trim().isEmpty() &&
               event.getEventType() != null &&
               event.getNewQuantity() != null && event.getNewQuantity() >= 0 &&
               event.getTimestamp() != null;
    }
    
    /**
     * Reprocessa eventos que falharam.
     * 
     * @return quantidade de eventos reprocessados
     */
    @Transactional
    public int reprocessFailedEvents() {
        List<InventoryEvent> failedEvents = inventoryEventRepository.findFailedEvents();
        
        log.info("üîÑ Reprocessando {} eventos que falharam", failedEvents.size());
        
        int reprocessedCount = 0;
        for (InventoryEvent event : failedEvents) {
            if (processInventoryEvent(event)) {
                reprocessedCount++;
            }
        }
        
        log.info("‚úÖ {} eventos reprocessados com sucesso", reprocessedCount);
        return reprocessedCount;
    }
}
